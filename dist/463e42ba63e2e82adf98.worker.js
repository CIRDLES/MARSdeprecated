/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _d3Dsv = __webpack_require__(1);\n\n// sandbox only recieves one message which tells it which files\n// will be used and how. Data is stored in e.data\nonmessage = function onmessage(e) {\n\n  if (e.data.type == 'map') {\n    // This callback chain contains all the logic of the webworker\n    readSourceMap(e.data.sourceMap, function (err, map, logic) {\n\n      // once the sourceMap is read, get the source data\n      readSourceData(e.data.sourceFormat, e.data.sourceFiles, map, logic, function (err, samples) {\n        postMessage(samples);\n        close();\n      });\n    });\n  } else if (e.data.type == 'combine') {\n    readSourceMap(e.data.sourceMap[0], function (err, map, logic, combinations) {\n      var combinedSamples = combineFields(combinations, map, e.data.uploadSamples);\n      postMessage(combinedSamples);\n      close();\n    });\n  }\n};\n\n// Read read source map. callback(err, map, logic)\n// code for a webworker so that user JS code can be run in a separate\n// thread from the main application. This disables the users ability\n// to access the application's global scope.\nvar readSourceMap = function readSourceMap(mapFile, callback) {\n  var reader = new FileReader();\n  reader.onload = function (e) {\n    var fileContents = Function(e.target.result)(); // rather than using eval, create a Function using the mapping file contents as the body\n    return callback(null, fileContents.map, fileContents.logic, fileContents.combinations);\n  };\n  reader.readAsText(mapFile);\n};\n\n// read source data using the proper loader\nvar readSourceData = function readSourceData(format, files, map, logic, callback) {\n  switch (format) {\n    case '.csv':\n      return loadCSV(files, map, logic, callback);\n    default:\n      return callback('ERROR');\n  }\n};\n\n// combine fields where necessary. This occurs only after the user clicks the upload button\n// to upload their samples to SESAR\nvar combineFields = function combineFields(combinations, map, uploadSamples) {\n  for (var i = 0; i < uploadSamples.length; i++) {\n    var _loop = function _loop(key) {\n      if (Array.isArray(map[key])) {\n        var filter = uploadSamples[i].filter(function (value) {\n          return map[key].includes(value.originalKey);\n        });\n        var inverse = uploadSamples[i].filter(function (value) {\n          return !map[key].includes(value.originalKey);\n        });\n        if (filter.length > 1) {\n          var reduction = filter.reduce(function (acc, field) {\n            return acc.concat([field.value]);\n          }, []);\n          if (combinations[key]) {\n            var newField = { key: key, value: combinations[key](reduction) };\n            inverse.push(newField);\n            uploadSamples[i] = inverse;\n          }\n        } else if (filter.length == 1) {\n          inverse.concat(filter);\n          uploadSamples[i] = inverse;\n        }\n      }\n    };\n\n    for (var key in map) {\n      _loop(key);\n    }\n  }\n  return uploadSamples;\n};\n\n// **********************************************************\n// loaders handle the logic for whatever file format is given\n// **********************************************************\n\n// createField is a helper function for all the loaders that builds each field\n// for MARS\nvar createField = function createField(key, originalValue, originalKey, logic) {\n  if (!key) {\n    return {\n      originalKey: originalKey,\n      originalValue: originalValue\n    };\n  }\n\n  return {\n    originalKey: originalKey,\n    originalValue: originalValue,\n    key: key,\n    value: logic[key] ? logic[key](originalValue, originalKey) : originalValue\n  };\n};\n\n// Load CSV files by merging them\nvar loadCSV = function loadCSV(files, map, logic, callback) {\n\n  var samples = [];\n  var counter = 0;\n\n  for (var i = 0; i < files.length; i++) {\n    // closure reads each file and fires callback when completed\n    (function (file) {\n\n      // create a fileReader for each file\n      var reader = new FileReader();\n\n      // Because FileReader is asynchronous, there is no guaranteed order in\n      // which each file will fire the onloadend event\n      reader.onloadend = function (e) {\n        // csvParse is a D3 function that loads a csv string. It takes a function\n        // which handles the logic for mapping each individual sample\n        (0, _d3Dsv.csvParse)(e.target.result, function (d, i) {\n          if (!samples[i]) {\n            samples[i] = [];\n          }\n          for (var key in map) {\n            if (Array.isArray(map[key])) {\n              for (var j = 0; j < map[key].length; j++) {\n                if (d[map[key][j]]) {\n                  samples[i].push(createField(key, d[map[key][j]], map[key][j], logic));\n                  delete d[map[key][i]];\n                }\n              }\n            } else if (d[map[key]]) {\n              samples[i].push(createField(key, d[map[key]], map[key], logic));\n              delete d[map[key]];\n            }\n          }\n          // Get the unmapped samples\n          for (var _key in d) {\n            d[_key] ? samples[i].push(createField(undefined, d[_key], _key, logic)) : false;\n          }\n        });\n\n        // the counter helps us know when all the files have been loaded by counting\n        // the number of loadend events that are fired\n        counter++;\n        if (counter == files.length) {\n          var _loop2 = function _loop2(_i) {\n            var seen = {};\n            samples[_i] = samples[_i].filter(function (field) {\n              return seen.hasOwnProperty(field.originalKey) ? false : seen[field.originalKey] = true;\n            });\n          };\n\n          // filter repeats with hash tables\n          for (var _i = 0; _i < samples.length; _i++) {\n            _loop2(_i);\n          }\n          callback(null, samples);\n        }\n      };\n      reader.readAsText(file);\n    })(files[i]); // end closure\n  }\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3RpYWN1cnJ5L01BUlMvbWFycy1uYXRpdmUvbWFycy1jbGllbnQvc3JjL21hcnMvY29tcG9uZW50cy9BcHAvY29tcG9uZW50cy9VcGxvYWQvaGVscGVycy9zYW5kYm94LmpzPzZiODAiXSwibmFtZXMiOlsib25tZXNzYWdlIiwiZSIsImRhdGEiLCJ0eXBlIiwicmVhZFNvdXJjZU1hcCIsInNvdXJjZU1hcCIsImVyciIsIm1hcCIsImxvZ2ljIiwicmVhZFNvdXJjZURhdGEiLCJzb3VyY2VGb3JtYXQiLCJzb3VyY2VGaWxlcyIsInNhbXBsZXMiLCJwb3N0TWVzc2FnZSIsImNsb3NlIiwiY29tYmluYXRpb25zIiwiY29tYmluZWRTYW1wbGVzIiwiY29tYmluZUZpZWxkcyIsInVwbG9hZFNhbXBsZXMiLCJtYXBGaWxlIiwiY2FsbGJhY2siLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwiZmlsZUNvbnRlbnRzIiwiRnVuY3Rpb24iLCJ0YXJnZXQiLCJyZXN1bHQiLCJyZWFkQXNUZXh0IiwiZm9ybWF0IiwiZmlsZXMiLCJsb2FkQ1NWIiwiaSIsImxlbmd0aCIsImtleSIsIkFycmF5IiwiaXNBcnJheSIsImZpbHRlciIsInZhbHVlIiwiaW5jbHVkZXMiLCJvcmlnaW5hbEtleSIsImludmVyc2UiLCJyZWR1Y3Rpb24iLCJyZWR1Y2UiLCJhY2MiLCJmaWVsZCIsImNvbmNhdCIsIm5ld0ZpZWxkIiwicHVzaCIsImNyZWF0ZUZpZWxkIiwib3JpZ2luYWxWYWx1ZSIsImNvdW50ZXIiLCJmaWxlIiwib25sb2FkZW5kIiwiZCIsImoiLCJ1bmRlZmluZWQiLCJzZWVuIiwiaGFzT3duUHJvcGVydHkiXSwibWFwcGluZ3MiOiI7O0FBR0E7O0FBRUE7QUFDQTtBQUNBQSxZQUFZLG1CQUFDQyxDQUFELEVBQU87O0FBRWpCLE1BQUdBLEVBQUVDLElBQUYsQ0FBT0MsSUFBUCxJQUFlLEtBQWxCLEVBQXlCO0FBQ3ZCO0FBQ0FDLGtCQUFjSCxF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ZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBjb2RlIGZvciBhIHdlYndvcmtlciBzbyB0aGF0IHVzZXIgSlMgY29kZSBjYW4gYmUgcnVuIGluIGEgc2VwYXJhdGVcbi8vIHRocmVhZCBmcm9tIHRoZSBtYWluIGFwcGxpY2F0aW9uLiBUaGlzIGRpc2FibGVzIHRoZSB1c2VycyBhYmlsaXR5XG4vLyB0byBhY2Nlc3MgdGhlIGFwcGxpY2F0aW9uJ3MgZ2xvYmFsIHNjb3BlLlxuaW1wb3J0IHtjc3ZQYXJzZX0gZnJvbSAnZDMtZHN2J1xuXG4vLyBzYW5kYm94IG9ubHkgcmVjaWV2ZXMgb25lIG1lc3NhZ2Ugd2hpY2ggdGVsbHMgaXQgd2hpY2ggZmlsZXNcbi8vIHdpbGwgYmUgdXNlZCBhbmQgaG93LiBEYXRhIGlzIHN0b3JlZCBpbiBlLmRhdGFcbm9ubWVzc2FnZSA9IChlKSA9PiB7XG5cbiAgaWYoZS5kYXRhLnR5cGUgPT0gJ21hcCcpIHtcbiAgICAvLyBUaGlzIGNhbGxiYWNrIGNoYWluIGNvbnRhaW5zIGFsbCB0aGUgbG9naWMgb2YgdGhlIHdlYndvcmtlclxuICAgIHJlYWRTb3VyY2VNYXAoZS5kYXRhLnNvdXJjZU1hcCwgKGVyciwgbWFwLCBsb2dpYykgPT4ge1xuXG4gICAgICAvLyBvbmNlIHRoZSBzb3VyY2VNYXAgaXMgcmVhZCwgZ2V0IHRoZSBzb3VyY2UgZGF0YVxuICAgICAgcmVhZFNvdXJjZURhdGEoZS5kYXRhLnNvdXJjZUZvcm1hdCwgZS5kYXRhLnNvdXJjZUZpbGVzLCBtYXAsIGxvZ2ljLCAoZXJyLCBzYW1wbGVzKSA9PiB7XG4gICAgICAgIHBvc3RNZXNzYWdlKHNhbXBsZXMpXG4gICAgICAgIGNsb3NlKClcbiAgICAgIH0pXG4gICAgfSlcbiAgfSBlbHNlIGlmIChlLmRhdGEudHlwZSA9PSAnY29tYmluZScpIHtcbiAgICByZWFkU291cmNlTWFwKGUuZGF0YS5zb3VyY2VNYXBbMF0sIChlcnIsIG1hcCwgbG9naWMsIGNvbWJpbmF0aW9ucykgPT4ge1xuICAgICAgbGV0IGNvbWJpbmVkU2FtcGxlcyA9IGNvbWJpbmVGaWVsZHMoY29tYmluYXRpb25zLCBtYXAsIGUuZGF0YS51cGxvYWRTYW1wbGVzKVxuICAgICAgcG9zdE1lc3NhZ2UoY29tYmluZWRTYW1wbGVzKVxuICAgICAgY2xvc2UoKVxuICAgIH0pXG4gIH1cbn1cblxuLy8gUmVhZCByZWFkIHNvdXJjZSBtYXAuIGNhbGxiYWNrKGVyciwgbWFwLCBsb2dpYylcbmNvbnN0IHJlYWRTb3VyY2VNYXAgPSAobWFwRmlsZSwgY2FsbGJhY2spID0+IHtcbiAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XG4gICAgbGV0IGZpbGVDb250ZW50cyA9IEZ1bmN0aW9uKGUudGFyZ2V0LnJlc3VsdCkoKSAvLyByYXRoZXIgdGhhbiB1c2luZyBldmFsLCBjcmVhdGUgYSBGdW5jdGlvbiB1c2luZyB0aGUgbWFwcGluZyBmaWxlIGNvbnRlbnRzIGFzIHRoZSBib2R5XG4gICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGZpbGVDb250ZW50cy5tYXAsIGZpbGVDb250ZW50cy5sb2dpYywgZmlsZUNvbnRlbnRzLmNvbWJpbmF0aW9ucylcbiAgfVxuICByZWFkZXIucmVhZEFzVGV4dChtYXBGaWxlKVxufVxuXG4vLyByZWFkIHNvdXJjZSBkYXRhIHVzaW5nIHRoZSBwcm9wZXIgbG9hZGVyXG5jb25zdCByZWFkU291cmNlRGF0YSA9IChmb3JtYXQsIGZpbGVzLCBtYXAsIGxvZ2ljLCBjYWxsYmFjaykgPT4ge1xuICBzd2l0Y2goZm9ybWF0KXtcbiAgICBjYXNlICcuY3N2JzpcbiAgICAgIHJldHVybiBsb2FkQ1NWKGZpbGVzLCBtYXAsIGxvZ2ljLCBjYWxsYmFjaylcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGNhbGxiYWNrKCdFUlJPUicpXG4gIH1cbn1cblxuLy8gY29tYmluZSBmaWVsZHMgd2hlcmUgbmVjZXNzYXJ5LiBUaGlzIG9jY3VycyBvbmx5IGFmdGVyIHRoZSB1c2VyIGNsaWNrcyB0aGUgdXBsb2FkIGJ1dHRvblxuLy8gdG8gdXBsb2FkIHRoZWlyIHNhbXBsZXMgdG8gU0VTQVJcbmNvbnN0IGNvbWJpbmVGaWVsZHMgPSAoY29tYmluYXRpb25zLCBtYXAsIHVwbG9hZFNhbXBsZXMpID0+IHtcbiAgZm9yKGxldCBpPTA7IGk8dXBsb2FkU2FtcGxlcy5sZW5ndGg7IGkrKykge1xuICAgIGZvcihsZXQga2V5IGluIG1hcCkge1xuICAgICAgaWYoQXJyYXkuaXNBcnJheShtYXBba2V5XSkpIHtcbiAgICAgICAgbGV0IGZpbHRlciA9IHVwbG9hZFNhbXBsZXNbaV0uZmlsdGVyKCh2YWx1ZSkgPT4gbWFwW2tleV0uaW5jbHVkZXModmFsdWUub3JpZ2luYWxLZXkpKVxuICAgICAgICBsZXQgaW52ZXJzZSA9IHVwbG9hZFNhbXBsZXNbaV0uZmlsdGVyKCh2YWx1ZSkgPT4gIW1hcFtrZXldLmluY2x1ZGVzKHZhbHVlLm9yaWdpbmFsS2V5KSlcbiAgICAgICAgaWYoZmlsdGVyLmxlbmd0aD4xKSB7XG4gICAgICAgICAgbGV0IHJlZHVjdGlvbiA9IGZpbHRlci5yZWR1Y2UoKGFjYywgZmllbGQpID0+IGFjYy5jb25jYXQoW2ZpZWxkLnZhbHVlXSksIFtdKVxuICAgICAgICAgIGlmKGNvbWJpbmF0aW9uc1trZXldKSB7XG4gICAgICAgICAgICBsZXQgbmV3RmllbGQgPSB7a2V5LCB2YWx1ZTogY29tYmluYXRpb25zW2tleV0ocmVkdWN0aW9uKX1cbiAgICAgICAgICAgIGludmVyc2UucHVzaChuZXdGaWVsZClcbiAgICAgICAgICAgIHVwbG9hZFNhbXBsZXNbaV0gPSBpbnZlcnNlXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoZmlsdGVyLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgaW52ZXJzZS5jb25jYXQoZmlsdGVyKVxuICAgICAgICAgIHVwbG9hZFNhbXBsZXNbaV0gPSBpbnZlcnNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVwbG9hZFNhbXBsZXNcbn1cblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8gbG9hZGVycyBoYW5kbGUgdGhlIGxvZ2ljIGZvciB3aGF0ZXZlciBmaWxlIGZvcm1hdCBpcyBnaXZlblxuLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4vLyBjcmVhdGVGaWVsZCBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgYWxsIHRoZSBsb2FkZXJzIHRoYXQgYnVpbGRzIGVhY2ggZmllbGRcbi8vIGZvciBNQVJTXG5jb25zdCBjcmVhdGVGaWVsZCA9IChrZXksIG9yaWdpbmFsVmFsdWUsIG9yaWdpbmFsS2V5LCBsb2dpYykgPT4ge1xuICBpZigha2V5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9yaWdpbmFsS2V5LFxuICAgICAgb3JpZ2luYWxWYWx1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb3JpZ2luYWxLZXksXG4gICAgb3JpZ2luYWxWYWx1ZSxcbiAgICBrZXksXG4gICAgdmFsdWU6IGxvZ2ljW2tleV0gPyBsb2dpY1trZXldKG9yaWdpbmFsVmFsdWUsIG9yaWdpbmFsS2V5KSA6IG9yaWdpbmFsVmFsdWVcbiAgfVxufVxuXG4vLyBMb2FkIENTViBmaWxlcyBieSBtZXJnaW5nIHRoZW1cbmNvbnN0IGxvYWRDU1YgPSAoZmlsZXMsIG1hcCwgbG9naWMsIGNhbGxiYWNrKSA9PiB7XG5cbiAgbGV0IHNhbXBsZXMgPSBbXVxuICBsZXQgY291bnRlciA9IDBcblxuICBmb3IobGV0IGk9MDsgaTxmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGNsb3N1cmUgcmVhZHMgZWFjaCBmaWxlIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIGNvbXBsZXRlZFxuICAgICgoZmlsZSkgPT4ge1xuXG4gICAgICAvLyBjcmVhdGUgYSBmaWxlUmVhZGVyIGZvciBlYWNoIGZpbGVcbiAgICAgIGxldCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG5cbiAgICAgIC8vIEJlY2F1c2UgRmlsZVJlYWRlciBpcyBhc3luY2hyb25vdXMsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZWQgb3JkZXIgaW5cbiAgICAgIC8vIHdoaWNoIGVhY2ggZmlsZSB3aWxsIGZpcmUgdGhlIG9ubG9hZGVuZCBldmVudFxuICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IChlKSA9PiB7XG4gICAgICAgIC8vIGNzdlBhcnNlIGlzIGEgRDMgZnVuY3Rpb24gdGhhdCBsb2FkcyBhIGNzdiBzdHJpbmcuIEl0IHRha2VzIGEgZnVuY3Rpb25cbiAgICAgICAgLy8gd2hpY2ggaGFuZGxlcyB0aGUgbG9naWMgZm9yIG1hcHBpbmcgZWFjaCBpbmRpdmlkdWFsIHNhbXBsZVxuICAgICAgICBjc3ZQYXJzZShlLnRhcmdldC5yZXN1bHQsIChkLCBpKSA9PiB7XG4gICAgICAgICAgaWYoIXNhbXBsZXNbaV0pIHtzYW1wbGVzW2ldID0gW119XG4gICAgICAgICAgZm9yKGxldCBrZXkgaW4gbWFwKSB7XG4gICAgICAgICAgICBpZihBcnJheS5pc0FycmF5KG1hcFtrZXldKSkge1xuICAgICAgICAgICAgICBmb3IobGV0IGo9MDsgajxtYXBba2V5XS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmKGRbbWFwW2tleV1bal1dKSB7XG4gICAgICAgICAgICAgICAgICBzYW1wbGVzW2ldLnB1c2goY3JlYXRlRmllbGQoa2V5LCBkW21hcFtrZXldW2pdXSwgbWFwW2tleV1bal0sIGxvZ2ljKSlcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkW21hcFtrZXldW2ldXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmKGRbbWFwW2tleV1dKXtcbiAgICAgICAgICAgICAgc2FtcGxlc1tpXS5wdXNoKGNyZWF0ZUZpZWxkKGtleSwgZFttYXBba2V5XV0sIG1hcFtrZXldLCBsb2dpYykpXG4gICAgICAgICAgICAgIGRlbGV0ZSBkW21hcFtrZXldXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBHZXQgdGhlIHVubWFwcGVkIHNhbXBsZXNcbiAgICAgICAgICBmb3IobGV0IGtleSBpbiBkKSB7XG4gICAgICAgICAgICBkW2tleV0gPyBzYW1wbGVzW2ldLnB1c2goY3JlYXRlRmllbGQodW5kZWZpbmVkLCBkW2tleV0sIGtleSwgbG9naWMpKSA6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIHRoZSBjb3VudGVyIGhlbHBzIHVzIGtub3cgd2hlbiBhbGwgdGhlIGZpbGVzIGhhdmUgYmVlbiBsb2FkZWQgYnkgY291bnRpbmdcbiAgICAgICAgLy8gdGhlIG51bWJlciBvZiBsb2FkZW5kIGV2ZW50cyB0aGF0IGFyZSBmaXJlZFxuICAgICAgICBjb3VudGVyKytcbiAgICAgICAgaWYoY291bnRlciA9PSBmaWxlcy5sZW5ndGgpIHtcblxuICAgICAgICAgIC8vIGZpbHRlciByZXBlYXRzIHdpdGggaGFzaCB0YWJsZXNcbiAgICAgICAgICBmb3IobGV0IGk9MDsgaTxzYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc2VlbiA9IHt9XG4gICAgICAgICAgICBzYW1wbGVzW2ldID0gc2FtcGxlc1tpXS5maWx0ZXIoZmllbGQgPT4gc2Vlbi5oYXNPd25Qcm9wZXJ0eShmaWVsZC5vcmlnaW5hbEtleSkgPyBmYWxzZSA6IChzZWVuW2ZpZWxkLm9yaWdpbmFsS2V5XSkgPSB0cnVlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBzYW1wbGVzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKVxuICAgIH0pKGZpbGVzW2ldKSAvLyBlbmQgY2xvc3VyZVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gL1VzZXJzL3RpYWN1cnJ5L01BUlMvbWFycy1uYXRpdmUvbWFycy1jbGllbnQvc3JjL21hcnMvY29tcG9uZW50cy9BcHAvY29tcG9uZW50cy9VcGxvYWQvaGVscGVycy9zYW5kYm94LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	eval("// https://d3js.org/d3-dsv/ Version 1.0.7. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n\t true ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.d3 = global.d3 || {})));\n}(this, (function (exports) { 'use strict';\n\nvar EOL = {};\nvar EOF = {};\nvar QUOTE = 34;\nvar NEWLINE = 10;\nvar RETURN = 13;\n\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"]\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function(row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n\n  rows.forEach(function(row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n\n  return columns;\n}\n\nvar dsv = function(delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"),\n      DELIMITER = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert, columns, rows = parseRows(text, function(row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns;\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var rows = [], // output rows\n        N = text.length,\n        I = 0, // current character index\n        n = 0, // current line number\n        t, // current token\n        eof = N <= 0, // current token followed by EOF?\n        eol = false; // current token followed by EOL?\n\n    // Strip the trailing newline.\n    if (text.charCodeAt(N - 1) === NEWLINE) --N;\n    if (text.charCodeAt(N - 1) === RETURN) --N;\n\n    function token() {\n      if (eof) return EOF;\n      if (eol) return eol = false, EOL;\n\n      // Unescape quotes.\n      var i, j = I, c;\n      if (text.charCodeAt(j) === QUOTE) {\n        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);\n        if ((i = I) >= N) eof = true;\n        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        return text.slice(j + 1, i - 1).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // Find next delimiter or newline.\n      while (I < N) {\n        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        else if (c !== DELIMITER) continue;\n        return text.slice(j, i);\n      }\n\n      // Return last token before EOF.\n      return eof = true, text.slice(j, N);\n    }\n\n    while ((t = token()) !== EOF) {\n      var row = [];\n      while (t !== EOL && t !== EOF) row.push(t), t = token();\n      if (f && (row = f(row, n++)) == null) continue;\n      rows.push(row);\n    }\n\n    return rows;\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {\n      return columns.map(function(column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    })).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(text) {\n    return text == null ? \"\"\n        : reFormat.test(text += \"\") ? \"\\\"\" + text.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\"\n        : text;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatRows: formatRows\n  };\n};\n\nvar csv = dsv(\",\");\n\nvar csvParse = csv.parse;\nvar csvParseRows = csv.parseRows;\nvar csvFormat = csv.format;\nvar csvFormatRows = csv.formatRows;\n\nvar tsv = dsv(\"\\t\");\n\nvar tsvParse = tsv.parse;\nvar tsvParseRows = tsv.parseRows;\nvar tsvFormat = tsv.format;\nvar tsvFormatRows = tsv.formatRows;\n\nexports.dsvFormat = dsv;\nexports.csvParse = csvParse;\nexports.csvParseRows = csvParseRows;\nexports.csvFormat = csvFormat;\nexports.csvFormatRows = csvFormatRows;\nexports.tsvParse = tsvParse;\nexports.tsvParseRows = tsvParseRows;\nexports.tsvFormat = tsvFormat;\nexports.tsvFormatRows = tsvFormatRows;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL3RpYWN1cnJ5L01BUlMvbWFycy1uYXRpdmUvbWFycy1jbGllbnQvfi9kMy1kc3YvYnVpbGQvZDMtZHN2LmpzP2M1ZjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsQ0FBQyw0QkFBNEI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxHQUFHLGdCQUFnQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVkseUNBQXlDO0FBQ3JGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVkseUNBQXlDO0FBQ3JGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYzs7QUFFNUQsQ0FBQyIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1kc3YvIFZlcnNpb24gMS4wLjcuIENvcHlyaWdodCAyMDE3IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIEVPTCA9IHt9O1xudmFyIEVPRiA9IHt9O1xudmFyIFFVT1RFID0gMzQ7XG52YXIgTkVXTElORSA9IDEwO1xudmFyIFJFVFVSTiA9IDEzO1xuXG5mdW5jdGlvbiBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucykge1xuICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwiZFwiLCBcInJldHVybiB7XCIgKyBjb2x1bW5zLm1hcChmdW5jdGlvbihuYW1lLCBpKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgXCI6IGRbXCIgKyBpICsgXCJdXCI7XG4gIH0pLmpvaW4oXCIsXCIpICsgXCJ9XCIpO1xufVxuXG5mdW5jdGlvbiBjdXN0b21Db252ZXJ0ZXIoY29sdW1ucywgZikge1xuICB2YXIgb2JqZWN0ID0gb2JqZWN0Q29udmVydGVyKGNvbHVtbnMpO1xuICByZXR1cm4gZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgcmV0dXJuIGYob2JqZWN0KHJvdyksIGksIGNvbHVtbnMpO1xuICB9O1xufVxuXG4vLyBDb21wdXRlIHVuaXF1ZSBjb2x1bW5zIGluIG9yZGVyIG9mIGRpc2NvdmVyeS5cbmZ1bmN0aW9uIGluZmVyQ29sdW1ucyhyb3dzKSB7XG4gIHZhciBjb2x1bW5TZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgY29sdW1ucyA9IFtdO1xuXG4gIHJvd3MuZm9yRWFjaChmdW5jdGlvbihyb3cpIHtcbiAgICBmb3IgKHZhciBjb2x1bW4gaW4gcm93KSB7XG4gICAgICBpZiAoIShjb2x1bW4gaW4gY29sdW1uU2V0KSkge1xuICAgICAgICBjb2x1bW5zLnB1c2goY29sdW1uU2V0W2NvbHVtbl0gPSBjb2x1bW4pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbHVtbnM7XG59XG5cbnZhciBkc3YgPSBmdW5jdGlvbihkZWxpbWl0ZXIpIHtcbiAgdmFyIHJlRm9ybWF0ID0gbmV3IFJlZ0V4cChcIltcXFwiXCIgKyBkZWxpbWl0ZXIgKyBcIlxcblxccl1cIiksXG4gICAgICBERUxJTUlURVIgPSBkZWxpbWl0ZXIuY2hhckNvZGVBdCgwKTtcblxuICBmdW5jdGlvbiBwYXJzZSh0ZXh0LCBmKSB7XG4gICAgdmFyIGNvbnZlcnQsIGNvbHVtbnMsIHJvd3MgPSBwYXJzZVJvd3ModGV4dCwgZnVuY3Rpb24ocm93LCBpKSB7XG4gICAgICBpZiAoY29udmVydCkgcmV0dXJuIGNvbnZlcnQocm93LCBpIC0gMSk7XG4gICAgICBjb2x1bW5zID0gcm93LCBjb252ZXJ0ID0gZiA/IGN1c3RvbUNvbnZlcnRlcihyb3csIGYpIDogb2JqZWN0Q29udmVydGVyKHJvdyk7XG4gICAgfSk7XG4gICAgcm93cy5jb2x1bW5zID0gY29sdW1ucztcbiAgICByZXR1cm4gcm93cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUm93cyh0ZXh0LCBmKSB7XG4gICAgdmFyIHJvd3MgPSBbXSwgLy8gb3V0cHV0IHJvd3NcbiAgICAgICAgTiA9IHRleHQubGVuZ3RoLFxuICAgICAgICBJID0gMCwgLy8gY3VycmVudCBjaGFyYWN0ZXIgaW5kZXhcbiAgICAgICAgbiA9IDAsIC8vIGN1cnJlbnQgbGluZSBudW1iZXJcbiAgICAgICAgdCwgLy8gY3VycmVudCB0b2tlblxuICAgICAgICBlb2YgPSBOIDw9IDAsIC8vIGN1cnJlbnQgdG9rZW4gZm9sbG93ZWQgYnkgRU9GP1xuICAgICAgICBlb2wgPSBmYWxzZTsgLy8gY3VycmVudCB0b2tlbiBmb2xsb3dlZCBieSBFT0w/XG5cbiAgICAvLyBTdHJpcCB0aGUgdHJhaWxpbmcgbmV3bGluZS5cbiAgICBpZiAodGV4dC5jaGFyQ29kZUF0KE4gLSAxKSA9PT0gTkVXTElORSkgLS1OO1xuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoTiAtIDEpID09PSBSRVRVUk4pIC0tTjtcblxuICAgIGZ1bmN0aW9uIHRva2VuKCkge1xuICAgICAgaWYgKGVvZikgcmV0dXJuIEVPRjtcbiAgICAgIGlmIChlb2wpIHJldHVybiBlb2wgPSBmYWxzZSwgRU9MO1xuXG4gICAgICAvLyBVbmVzY2FwZSBxdW90ZXMuXG4gICAgICB2YXIgaSwgaiA9IEksIGM7XG4gICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGopID09PSBRVU9URSkge1xuICAgICAgICB3aGlsZSAoSSsrIDwgTiAmJiB0ZXh0LmNoYXJDb2RlQXQoSSkgIT09IFFVT1RFIHx8IHRleHQuY2hhckNvZGVBdCgrK0kpID09PSBRVU9URSk7XG4gICAgICAgIGlmICgoaSA9IEkpID49IE4pIGVvZiA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKChjID0gdGV4dC5jaGFyQ29kZUF0KEkrKykpID09PSBORVdMSU5FKSBlb2wgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjID09PSBSRVRVUk4pIHsgZW9sID0gdHJ1ZTsgaWYgKHRleHQuY2hhckNvZGVBdChJKSA9PT0gTkVXTElORSkgKytJOyB9XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGogKyAxLCBpIC0gMSkucmVwbGFjZSgvXCJcIi9nLCBcIlxcXCJcIik7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgbmV4dCBkZWxpbWl0ZXIgb3IgbmV3bGluZS5cbiAgICAgIHdoaWxlIChJIDwgTikge1xuICAgICAgICBpZiAoKGMgPSB0ZXh0LmNoYXJDb2RlQXQoaSA9IEkrKykpID09PSBORVdMSU5FKSBlb2wgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjID09PSBSRVRVUk4pIHsgZW9sID0gdHJ1ZTsgaWYgKHRleHQuY2hhckNvZGVBdChJKSA9PT0gTkVXTElORSkgKytJOyB9XG4gICAgICAgIGVsc2UgaWYgKGMgIT09IERFTElNSVRFUikgY29udGludWU7XG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKGosIGkpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gbGFzdCB0b2tlbiBiZWZvcmUgRU9GLlxuICAgICAgcmV0dXJuIGVvZiA9IHRydWUsIHRleHQuc2xpY2UoaiwgTik7XG4gICAgfVxuXG4gICAgd2hpbGUgKCh0ID0gdG9rZW4oKSkgIT09IEVPRikge1xuICAgICAgdmFyIHJvdyA9IFtdO1xuICAgICAgd2hpbGUgKHQgIT09IEVPTCAmJiB0ICE9PSBFT0YpIHJvdy5wdXNoKHQpLCB0ID0gdG9rZW4oKTtcbiAgICAgIGlmIChmICYmIChyb3cgPSBmKHJvdywgbisrKSkgPT0gbnVsbCkgY29udGludWU7XG4gICAgICByb3dzLnB1c2gocm93KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm93cztcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdChyb3dzLCBjb2x1bW5zKSB7XG4gICAgaWYgKGNvbHVtbnMgPT0gbnVsbCkgY29sdW1ucyA9IGluZmVyQ29sdW1ucyhyb3dzKTtcbiAgICByZXR1cm4gW2NvbHVtbnMubWFwKGZvcm1hdFZhbHVlKS5qb2luKGRlbGltaXRlcildLmNvbmNhdChyb3dzLm1hcChmdW5jdGlvbihyb3cpIHtcbiAgICAgIHJldHVybiBjb2x1bW5zLm1hcChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdFZhbHVlKHJvd1tjb2x1bW5dKTtcbiAgICAgIH0pLmpvaW4oZGVsaW1pdGVyKTtcbiAgICB9KSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFJvd3Mocm93cykge1xuICAgIHJldHVybiByb3dzLm1hcChmb3JtYXRSb3cpLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRSb3cocm93KSB7XG4gICAgcmV0dXJuIHJvdy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFZhbHVlKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dCA9PSBudWxsID8gXCJcIlxuICAgICAgICA6IHJlRm9ybWF0LnRlc3QodGV4dCArPSBcIlwiKSA/IFwiXFxcIlwiICsgdGV4dC5yZXBsYWNlKC9cIi9nLCBcIlxcXCJcXFwiXCIpICsgXCJcXFwiXCJcbiAgICAgICAgOiB0ZXh0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwYXJzZTogcGFyc2UsXG4gICAgcGFyc2VSb3dzOiBwYXJzZVJvd3MsXG4gICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgZm9ybWF0Um93czogZm9ybWF0Um93c1xuICB9O1xufTtcblxudmFyIGNzdiA9IGRzdihcIixcIik7XG5cbnZhciBjc3ZQYXJzZSA9IGNzdi5wYXJzZTtcbnZhciBjc3ZQYXJzZVJvd3MgPSBjc3YucGFyc2VSb3dzO1xudmFyIGNzdkZvcm1hdCA9IGNzdi5mb3JtYXQ7XG52YXIgY3N2Rm9ybWF0Um93cyA9IGNzdi5mb3JtYXRSb3dzO1xuXG52YXIgdHN2ID0gZHN2KFwiXFx0XCIpO1xuXG52YXIgdHN2UGFyc2UgPSB0c3YucGFyc2U7XG52YXIgdHN2UGFyc2VSb3dzID0gdHN2LnBhcnNlUm93cztcbnZhciB0c3ZGb3JtYXQgPSB0c3YuZm9ybWF0O1xudmFyIHRzdkZvcm1hdFJvd3MgPSB0c3YuZm9ybWF0Um93cztcblxuZXhwb3J0cy5kc3ZGb3JtYXQgPSBkc3Y7XG5leHBvcnRzLmNzdlBhcnNlID0gY3N2UGFyc2U7XG5leHBvcnRzLmNzdlBhcnNlUm93cyA9IGNzdlBhcnNlUm93cztcbmV4cG9ydHMuY3N2Rm9ybWF0ID0gY3N2Rm9ybWF0O1xuZXhwb3J0cy5jc3ZGb3JtYXRSb3dzID0gY3N2Rm9ybWF0Um93cztcbmV4cG9ydHMudHN2UGFyc2UgPSB0c3ZQYXJzZTtcbmV4cG9ydHMudHN2UGFyc2VSb3dzID0gdHN2UGFyc2VSb3dzO1xuZXhwb3J0cy50c3ZGb3JtYXQgPSB0c3ZGb3JtYXQ7XG5leHBvcnRzLnRzdkZvcm1hdFJvd3MgPSB0c3ZGb3JtYXRSb3dzO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gL1VzZXJzL3RpYWN1cnJ5L01BUlMvbWFycy1uYXRpdmUvbWFycy1jbGllbnQvfi9kMy1kc3YvYnVpbGQvZDMtZHN2LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ })
/******/ ]);