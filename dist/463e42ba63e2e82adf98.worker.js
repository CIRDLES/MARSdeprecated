/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _d3Dsv = __webpack_require__(1);\n\n// sandbox only recieves one message which tells it which files\n// will be used and how. Data is stored in e.data\nonmessage = function onmessage(e) {\n\n  if (e.data.type == 'map') {\n    // This callback chain contains all the logic of the webworker\n    readSourceMap(e.data.sourceMap, function (err, map, logic) {\n\n      // once the sourceMap is read, get the source data\n      readSourceData(e.data.sourceFormat, e.data.sourceFiles, map, logic, function (err, samples) {\n        postMessage(samples);\n        close();\n      });\n    });\n  } else if (e.data.type == 'combine') {\n    readSourceMap(e.data.sourceMap[0], function (err, map, logic, combinations) {\n      var combinedSamples = combineFields(combinations, map, e.data.uploadSamples);\n      postMessage(combinedSamples);\n      close();\n    });\n  }\n};\n\n// Read read source map. callback(err, map, logic)\n// code for a webworker so that user JS code can be run in a separate\n// thread from the main application. This disables the users ability\n// to access the application's global scope.\nvar readSourceMap = function readSourceMap(mapFile, callback) {\n  var reader = new FileReader();\n  reader.onload = function (e) {\n    var fileContents = Function(e.target.result)(); // rather than using eval, create a Function using the mapping file contents as the body\n    return callback(null, fileContents.map, fileContents.logic, fileContents.combinations);\n  };\n  reader.readAsText(mapFile);\n};\n\n// read source data using the proper loader\nvar readSourceData = function readSourceData(format, files, map, logic, callback) {\n  switch (format) {\n    case '.csv':\n      return loadCSV(files, map, logic, callback);\n    default:\n      return callback('ERROR');\n  }\n};\n\n// combine fields where necessary. This occurs only after the user clicks the upload button\n// to upload their samples to SESAR\nvar combineFields = function combineFields(combinations, map, uploadSamples) {\n  for (var i = 0; i < uploadSamples.length; i++) {\n    var _loop = function _loop(key) {\n      if (Array.isArray(map[key])) {\n        var filter = uploadSamples[i].filter(function (value) {\n          return map[key].includes(value.originalKey);\n        });\n        var inverse = uploadSamples[i].filter(function (value) {\n          return !map[key].includes(value.originalKey);\n        });\n        if (filter.length > 1) {\n          var reduction = filter.reduce(function (acc, field) {\n            return acc.concat([field.value]);\n          }, []);\n          if (combinations[key]) {\n            var newField = { key: key, value: combinations[key](reduction) };\n            inverse.push(newField);\n            uploadSamples[i] = inverse;\n          }\n        } else if (filter.length == 1) {\n          inverse.concat(filter);\n          uploadSamples[i] = inverse;\n        }\n      }\n    };\n\n    for (var key in map) {\n      _loop(key);\n    }\n  }\n  return uploadSamples;\n};\n\n// **********************************************************\n// loaders handle the logic for whatever file format is given\n// **********************************************************\n\n// createField is a helper function for all the loaders that builds each field\n// for MARS\nvar createField = function createField(key, originalValue, originalKey, logic) {\n  if (!key) {\n    return {\n      originalKey: originalKey,\n      originalValue: originalValue\n    };\n  }\n\n  return {\n    originalKey: originalKey,\n    originalValue: originalValue,\n    key: key,\n    value: logic[key] ? logic[key](originalValue, originalKey) : originalValue\n  };\n};\n\n// Load CSV files by merging them\nvar loadCSV = function loadCSV(files, map, logic, callback) {\n\n  var samples = [];\n  var counter = 0;\n\n  for (var i = 0; i < files.length; i++) {\n    // closure reads each file and fires callback when completed\n    (function (file) {\n\n      // create a fileReader for each file\n      var reader = new FileReader();\n\n      // Because FileReader is asynchronous, there is no guaranteed order in\n      // which each file will fire the onloadend event\n      reader.onloadend = function (e) {\n        // csvParse is a D3 function that loads a csv string. It takes a function\n        // which handles the logic for mapping each individual sample\n        (0, _d3Dsv.csvParse)(e.target.result, function (d, i) {\n          if (!samples[i]) {\n            samples[i] = [];\n          }\n          for (var key in map) {\n            if (Array.isArray(map[key])) {\n              for (var j = 0; j < map[key].length; j++) {\n                if (d[map[key][j]]) {\n                  samples[i].push(createField(key, d[map[key][j]], map[key][j], logic));\n                  delete d[map[key][i]];\n                }\n              }\n            } else if (d[map[key]]) {\n              samples[i].push(createField(key, d[map[key]], map[key], logic));\n              delete d[map[key]];\n            }\n          }\n          // Get the unmapped samples\n          for (var _key in d) {\n            d[_key] ? samples[i].push(createField(undefined, d[_key], _key, logic)) : false;\n          }\n        });\n\n        // the counter helps us know when all the files have been loaded by counting\n        // the number of loadend events that are fired\n        counter++;\n        if (counter == files.length) {\n          var _loop2 = function _loop2(_i) {\n            var seen = {};\n            samples[_i] = samples[_i].filter(function (field) {\n              return seen.hasOwnProperty(field.originalKey) ? false : seen[field.originalKey] = true;\n            });\n          };\n\n          // filter repeats with hash tables\n          for (var _i = 0; _i < samples.length; _i++) {\n            _loop2(_i);\n          }\n          callback(null, samples);\n        }\n      };\n      reader.readAsText(file);\n    })(files[i]); // end closure\n  }\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFycy9jb21wb25lbnRzL0FwcC9jb21wb25lbnRzL1VwbG9hZC9oZWxwZXJzL3NhbmRib3guanM/ZDhiYSJdLCJuYW1lcyI6WyJvbm1lc3NhZ2UiLCJlIiwiZGF0YSIsInR5cGUiLCJyZWFkU291cmNlTWFwIiwic291cmNlTWFwIiwiZXJyIiwibWFwIiwibG9naWMiLCJyZWFkU291cmNlRGF0YSIsInNvdXJjZUZvcm1hdCIsInNvdXJjZUZpbGVzIiwic2FtcGxlcyIsInBvc3RNZXNzYWdlIiwiY2xvc2UiLCJjb21iaW5hdGlvbnMiLCJjb21iaW5lZFNhbXBsZXMiLCJjb21iaW5lRmllbGRzIiwidXBsb2FkU2FtcGxlcyIsIm1hcEZpbGUiLCJjYWxsYmFjayIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJmaWxlQ29udGVudHMiLCJGdW5jdGlvbiIsInRhcmdldCIsInJlc3VsdCIsInJlYWRBc1RleHQiLCJmb3JtYXQiLCJmaWxlcyIsImxvYWRDU1YiLCJpIiwibGVuZ3RoIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5IiwiZmlsdGVyIiwidmFsdWUiLCJpbmNsdWRlcyIsIm9yaWdpbmFsS2V5IiwiaW52ZXJzZSIsInJlZHVjdGlvbiIsInJlZHVjZSIsImFjYyIsImZpZWxkIiwiY29uY2F0IiwibmV3RmllbGQiLCJwdXNoIiwiY3JlYXRlRmllbGQiLCJvcmlnaW5hbFZhbHVlIiwiY291bnRlciIsImZpbGUiLCJvbmxvYWRlbmQiLCJkIiwiaiIsInVuZGVmaW5lZCIsInNlZW4iLCJoYXNPd25Qcm9wZXJ0eSJdLCJtYXBwaW5ncyI6Ijs7QUFHQTs7QUFFQTtBQUNBO0FBQ0FBLFlBQVksbUJBQUNDLENBQUQsRUFBTzs7QUFFakIsTUFBR0EsRUFBRUMsSUFBRixDQUFPQyxJQUFQLElBQWUsS0FBbEIsRUFBeUI7QUFDdkI7QUFDQUMsa0JBQWNILEVBQUVDLElBQUYsQ0FBT0csU0FBckIsRUFBZ0MsVUFBQ0MsR0FBRCxFQUFNQyxHQUFOLEVBQVdDLEtBQVgsRUFBcUI7O0FBRW5EO0FBQ0FDLHFCQUFlUixFQUFFQyxJQUFGLENBQU9RLFlBQXRCLEVBQW9DVCxFQUFFQyxJQUFGLENBQU9TLFdBQTNDLEVBQXdESixHQUF4RCxFQUE2REMsS0FBN0QsRUFBb0UsVUFBQ0YsR0FBRCxFQUFNTSxPQUFOLEVBQWtCO0FBQ3BGQyxvQkFBWUQsT0FBWjtBQUNBRTtBQUNELE9BSEQ7QUFJRCxLQVBEO0FBUUQsR0FWRCxNQVVPLElBQUliLEVBQUVDLElBQUYsQ0FBT0MsSUFBUCxJQUFlLFNBQW5CLEVBQThCO0FBQ25DQyxrQkFBY0gsRUFBRUMsSUFBRixDQUFPRyxTQUFQLENBQWlCLENBQWpCLENBQWQsRUFBbUMsVUFBQ0MsR0FBRCxFQUFNQyxHQUFOLEVBQVdDLEtBQVgsRUFBa0JPLFlBQWxCLEVBQW1DO0FBQ3BFLFVBQUlDLGtCQUFrQkMsY0FBY0YsWUFBZCxFQUE0QlIsR0FBNUIsRUFBaUNOLEVBQUVDLElBQUYsQ0FBT2dCLGFBQXhDLENBQXRCO0FBQ0FMLGtCQUFZRyxlQUFaO0FBQ0FGO0FBQ0QsS0FKRDtBQUtEO0FBQ0YsQ0FuQkQ7O0FBcUJBO0FBNUJBO0FBQ0E7QUFDQTtBQTJCQSxJQUFNVixnQkFBZ0IsU0FBaEJBLGFBQWdCLENBQUNlLE9BQUQsRUFBVUMsUUFBVixFQUF1QjtBQUMzQyxNQUFJQyxTQUFTLElBQUlDLFVBQUosRUFBYjtBQUNBRCxTQUFPRSxNQUFQLEdBQWdCLFVBQUN0QixDQUFELEVBQU87QUFDckIsUUFBSXVCLGVBQWVDLFNBQVN4QixFQUFFeUIsTUFBRixDQUFTQyxNQUFsQixHQUFuQixDQURxQixDQUMwQjtBQUMvQyxXQUFPUCxTQUFTLElBQVQsRUFBZUksYUFBYWpCLEdBQTVCLEVBQWlDaUIsYUFBYWhCLEtBQTlDLEVBQXFEZ0IsYUFBYVQsWUFBbEUsQ0FBUDtBQUNELEdBSEQ7QUFJQU0sU0FBT08sVUFBUCxDQUFrQlQsT0FBbEI7QUFDRCxDQVBEOztBQVNBO0FBQ0EsSUFBTVYsaUJBQWlCLFNBQWpCQSxjQUFpQixDQUFDb0IsTUFBRCxFQUFTQyxLQUFULEVBQWdCdkIsR0FBaEIsRUFBcUJDLEtBQXJCLEVBQTRCWSxRQUE1QixFQUF5QztBQUM5RCxVQUFPUyxNQUFQO0FBQ0UsU0FBSyxNQUFMO0FBQ0UsYUFBT0UsUUFBUUQsS0FBUixFQUFldkIsR0FBZixFQUFvQkMsS0FBcEIsRUFBMkJZLFFBQTNCLENBQVA7QUFDRjtBQUNFLGFBQU9BLFNBQVMsT0FBVCxDQUFQO0FBSko7QUFNRCxDQVBEOztBQVNBO0FBQ0E7QUFDQSxJQUFNSCxnQkFBZ0IsU0FBaEJBLGFBQWdCLENBQUNGLFlBQUQsRUFBZVIsR0FBZixFQUFvQlcsYUFBcEIsRUFBc0M7QUFDMUQsT0FBSSxJQUFJYyxJQUFFLENBQVYsRUFBYUEsSUFBRWQsY0FBY2UsTUFBN0IsRUFBcUNELEdBQXJDLEVBQTBDO0FBQUEsK0JBQ2hDRSxHQURnQztBQUV0QyxVQUFHQyxNQUFNQyxPQUFOLENBQWM3QixJQUFJMkIsR0FBSixDQUFkLENBQUgsRUFBNEI7QUFDMUIsWUFBSUcsU0FBU25CLGNBQWNjLENBQWQsRUFBaUJLLE1BQWpCLENBQXdCLFVBQUNDLEtBQUQ7QUFBQSxpQkFBVy9CLElBQUkyQixHQUFKLEVBQVNLLFFBQVQsQ0FBa0JELE1BQU1FLFdBQXhCLENBQVg7QUFBQSxTQUF4QixDQUFiO0FBQ0EsWUFBSUMsVUFBVXZCLGNBQWNjLENBQWQsRUFBaUJLLE1BQWpCLENBQXdCLFVBQUNDLEtBQUQ7QUFBQSxpQkFBVyxDQUFDL0IsSUFBSTJCLEdBQUosRUFBU0ssUUFBVCxDQUFrQkQsTUFBTUUsV0FBeEIsQ0FBWjtBQUFBLFNBQXhCLENBQWQ7QUFDQSxZQUFHSCxPQUFPSixNQUFQLEdBQWMsQ0FBakIsRUFBb0I7QUFDbEIsY0FBSVMsWUFBWUwsT0FBT00sTUFBUCxDQUFjLFVBQUNDLEdBQUQsRUFBTUMsS0FBTjtBQUFBLG1CQUFnQkQsSUFBSUUsTUFBSixDQUFXLENBQUNELE1BQU1QLEtBQVAsQ0FBWCxDQUFoQjtBQUFBLFdBQWQsRUFBeUQsRUFBekQsQ0FBaEI7QUFDQSxjQUFHdkIsYUFBYW1CLEdBQWIsQ0FBSCxFQUFzQjtBQUNwQixnQkFBSWEsV0FBVyxFQUFDYixRQUFELEVBQU1JLE9BQU92QixhQUFhbUIsR0FBYixFQUFrQlEsU0FBbEIsQ0FBYixFQUFmO0FBQ0FELG9CQUFRTyxJQUFSLENBQWFELFFBQWI7QUFDQTdCLDBCQUFjYyxDQUFkLElBQW1CUyxPQUFuQjtBQUNEO0FBQ0YsU0FQRCxNQU9PLElBQUdKLE9BQU9KLE1BQVAsSUFBaUIsQ0FBcEIsRUFBdUI7QUFDNUJRLGtCQUFRSyxNQUFSLENBQWVULE1BQWY7QUFDQW5CLHdCQUFjYyxDQUFkLElBQW1CUyxPQUFuQjtBQUNEO0FBQ0Y7QUFoQnFDOztBQUN4QyxTQUFJLElBQUlQLEdBQVIsSUFBZTNCLEdBQWYsRUFBb0I7QUFBQSxZQUFaMkIsR0FBWTtBQWdCbkI7QUFDRjtBQUNELFNBQU9oQixhQUFQO0FBQ0QsQ0FyQkQ7O0FBdUJBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBTStCLGNBQWMsU0FBZEEsV0FBYyxDQUFDZixHQUFELEVBQU1nQixhQUFOLEVBQXFCVixXQUFyQixFQUFrQ2hDLEtBQWxDLEVBQTRDO0FBQzlELE1BQUcsQ0FBQzBCLEdBQUosRUFBUztBQUNQLFdBQU87QUFDTE0sOEJBREs7QUFFTFU7QUFGSyxLQUFQO0FBSUQ7O0FBRUQsU0FBTztBQUNMViw0QkFESztBQUVMVSxnQ0FGSztBQUdMaEIsWUFISztBQUlMSSxXQUFPOUIsTUFBTTBCLEdBQU4sSUFBYTFCLE1BQU0wQixHQUFOLEVBQVdnQixhQUFYLEVBQTBCVixXQUExQixDQUFiLEdBQXNEVTtBQUp4RCxHQUFQO0FBTUQsQ0FkRDs7QUFnQkE7QUFDQSxJQUFNbkIsVUFBVSxTQUFWQSxPQUFVLENBQUNELEtBQUQsRUFBUXZCLEdBQVIsRUFBYUMsS0FBYixFQUFvQlksUUFBcEIsRUFBaUM7O0FBRS9DLE1BQUlSLFVBQVUsRUFBZDtBQUNBLE1BQUl1QyxVQUFVLENBQWQ7O0FBRUEsT0FBSSxJQUFJbkIsSUFBRSxDQUFWLEVBQWFBLElBQUVGLE1BQU1HLE1BQXJCLEVBQTZCRCxHQUE3QixFQUFrQztBQUNoQztBQUNBLEtBQUMsVUFBQ29CLElBQUQsRUFBVTs7QUFFVDtBQUNBLFVBQUkvQixTQUFTLElBQUlDLFVBQUosRUFBYjs7QUFFQTtBQUNBO0FBQ0FELGFBQU9nQyxTQUFQLEdBQW1CLFVBQUNwRCxDQUFELEVBQU87QUFDeEI7QUFDQTtBQUNBLDZCQUFTQSxFQUFFeUIsTUFBRixDQUFTQyxNQUFsQixFQUEwQixVQUFDMkIsQ0FBRCxFQUFJdEIsQ0FBSixFQUFVO0FBQ2xDLGNBQUcsQ0FBQ3BCLFFBQVFvQixDQUFSLENBQUosRUFBZ0I7QUFBQ3BCLG9CQUFRb0IsQ0FBUixJQUFhLEVBQWI7QUFBZ0I7QUFDakMsZUFBSSxJQUFJRSxHQUFSLElBQWUzQixHQUFmLEVBQW9CO0FBQ2xCLGdCQUFHNEIsTUFBTUMsT0FBTixDQUFjN0IsSUFBSTJCLEdBQUosQ0FBZCxDQUFILEVBQTRCO0FBQzFCLG1CQUFJLElBQUlxQixJQUFFLENBQVYsRUFBYUEsSUFBRWhELElBQUkyQixHQUFKLEVBQVNELE1BQXhCLEVBQWdDc0IsR0FBaEMsRUFBcUM7QUFDbkMsb0JBQUdELEVBQUUvQyxJQUFJMkIsR0FBSixFQUFTcUIsQ0FBVCxDQUFGLENBQUgsRUFBbUI7QUFDakIzQywwQkFBUW9CLENBQVIsRUFBV2dCLElBQVgsQ0FBZ0JDLFlBQVlmLEdBQVosRUFBaUJvQixFQUFFL0MsSUFBSTJCLEdBQUosRUFBU3FCLENBQVQsQ0FBRixDQUFqQixFQUFpQ2hELElBQUkyQixHQUFKLEVBQVNxQixDQUFULENBQWpDLEVBQThDL0MsS0FBOUMsQ0FBaEI7QUFDQSx5QkFBTzhDLEVBQUUvQyxJQUFJMkIsR0FBSixFQUFTRixDQUFULENBQUYsQ0FBUDtBQUNEO0FBQ0Y7QUFDRixhQVBELE1BT08sSUFBR3NCLEVBQUUvQyxJQUFJMkIsR0FBSixDQUFGLENBQUgsRUFBZTtBQUNwQnRCLHNCQUFRb0IsQ0FBUixFQUFXZ0IsSUFBWCxDQUFnQkMsWUFBWWYsR0FBWixFQUFpQm9CLEVBQUUvQyxJQUFJMkIsR0FBSixDQUFGLENBQWpCLEVBQThCM0IsSUFBSTJCLEdBQUosQ0FBOUIsRUFBd0MxQixLQUF4QyxDQUFoQjtBQUNBLHFCQUFPOEMsRUFBRS9DLElBQUkyQixHQUFKLENBQUYsQ0FBUDtBQUNEO0FBQ0Y7QUFDRDtBQUNBLGVBQUksSUFBSUEsSUFBUixJQUFlb0IsQ0FBZixFQUFrQjtBQUNoQkEsY0FBRXBCLElBQUYsSUFBU3RCLFFBQVFvQixDQUFSLEVBQVdnQixJQUFYLENBQWdCQyxZQUFZTyxTQUFaLEVBQXVCRixFQUFFcEIsSUFBRixDQUF2QixFQUErQkEsSUFBL0IsRUFBb0MxQixLQUFwQyxDQUFoQixDQUFULEdBQXVFLEtBQXZFO0FBQ0Q7QUFDRixTQW5CRDs7QUFxQkE7QUFDQTtBQUNBMkM7QUFDQSxZQUFHQSxXQUFXckIsTUFBTUcsTUFBcEIsRUFBNEI7QUFBQSx1Q0FHbEJELEVBSGtCO0FBSXhCLGdCQUFJeUIsT0FBTyxFQUFYO0FBQ0E3QyxvQkFBUW9CLEVBQVIsSUFBYXBCLFFBQVFvQixFQUFSLEVBQVdLLE1BQVgsQ0FBa0I7QUFBQSxxQkFBU29CLEtBQUtDLGNBQUwsQ0FBb0JiLE1BQU1MLFdBQTFCLElBQXlDLEtBQXpDLEdBQWtEaUIsS0FBS1osTUFBTUwsV0FBWCxDQUFELEdBQTRCLElBQXRGO0FBQUEsYUFBbEIsQ0FBYjtBQUx3Qjs7QUFFMUI7QUFDQSxlQUFJLElBQUlSLEtBQUUsQ0FBVixFQUFhQSxLQUFFcEIsUUFBUXFCLE1BQXZCLEVBQStCRCxJQUEvQixFQUFvQztBQUFBLG1CQUE1QkEsRUFBNEI7QUFHbkM7QUFDRFosbUJBQVMsSUFBVCxFQUFlUixPQUFmO0FBQ0Q7QUFDRixPQXBDRDtBQXFDQVMsYUFBT08sVUFBUCxDQUFrQndCLElBQWxCO0FBQ0QsS0E3Q0QsRUE2Q0d0QixNQUFNRSxDQUFOLENBN0NILEVBRmdDLENBK0NuQjtBQUNkO0FBQ0YsQ0F0REQiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGNvZGUgZm9yIGEgd2Vid29ya2VyIHNvIHRoYXQgdXNlciBKUyBjb2RlIGNhbiBiZSBydW4gaW4gYSBzZXBhcmF0ZVxuLy8gdGhyZWFkIGZyb20gdGhlIG1haW4gYXBwbGljYXRpb24uIFRoaXMgZGlzYWJsZXMgdGhlIHVzZXJzIGFiaWxpdHlcbi8vIHRvIGFjY2VzcyB0aGUgYXBwbGljYXRpb24ncyBnbG9iYWwgc2NvcGUuXG5pbXBvcnQge2NzdlBhcnNlfSBmcm9tICdkMy1kc3YnXG5cbi8vIHNhbmRib3ggb25seSByZWNpZXZlcyBvbmUgbWVzc2FnZSB3aGljaCB0ZWxscyBpdCB3aGljaCBmaWxlc1xuLy8gd2lsbCBiZSB1c2VkIGFuZCBob3cuIERhdGEgaXMgc3RvcmVkIGluIGUuZGF0YVxub25tZXNzYWdlID0gKGUpID0+IHtcblxuICBpZihlLmRhdGEudHlwZSA9PSAnbWFwJykge1xuICAgIC8vIFRoaXMgY2FsbGJhY2sgY2hhaW4gY29udGFpbnMgYWxsIHRoZSBsb2dpYyBvZiB0aGUgd2Vid29ya2VyXG4gICAgcmVhZFNvdXJjZU1hcChlLmRhdGEuc291cmNlTWFwLCAoZXJyLCBtYXAsIGxvZ2ljKSA9PiB7XG5cbiAgICAgIC8vIG9uY2UgdGhlIHNvdXJjZU1hcCBpcyByZWFkLCBnZXQgdGhlIHNvdXJjZSBkYXRhXG4gICAgICByZWFkU291cmNlRGF0YShlLmRhdGEuc291cmNlRm9ybWF0LCBlLmRhdGEuc291cmNlRmlsZXMsIG1hcCwgbG9naWMsIChlcnIsIHNhbXBsZXMpID0+IHtcbiAgICAgICAgcG9zdE1lc3NhZ2Uoc2FtcGxlcylcbiAgICAgICAgY2xvc2UoKVxuICAgICAgfSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKGUuZGF0YS50eXBlID09ICdjb21iaW5lJykge1xuICAgIHJlYWRTb3VyY2VNYXAoZS5kYXRhLnNvdXJjZU1hcFswXSwgKGVyciwgbWFwLCBsb2dpYywgY29tYmluYXRpb25zKSA9PiB7XG4gICAgICBsZXQgY29tYmluZWRTYW1wbGVzID0gY29tYmluZUZpZWxkcyhjb21iaW5hdGlvbnMsIG1hcCwgZS5kYXRhLnVwbG9hZFNhbXBsZXMpXG4gICAgICBwb3N0TWVzc2FnZShjb21iaW5lZFNhbXBsZXMpXG4gICAgICBjbG9zZSgpXG4gICAgfSlcbiAgfVxufVxuXG4vLyBSZWFkIHJlYWQgc291cmNlIG1hcC4gY2FsbGJhY2soZXJyLCBtYXAsIGxvZ2ljKVxuY29uc3QgcmVhZFNvdXJjZU1hcCA9IChtYXBGaWxlLCBjYWxsYmFjaykgPT4ge1xuICBsZXQgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICByZWFkZXIub25sb2FkID0gKGUpID0+IHtcbiAgICBsZXQgZmlsZUNvbnRlbnRzID0gRnVuY3Rpb24oZS50YXJnZXQucmVzdWx0KSgpIC8vIHJhdGhlciB0aGFuIHVzaW5nIGV2YWwsIGNyZWF0ZSBhIEZ1bmN0aW9uIHVzaW5nIHRoZSBtYXBwaW5nIGZpbGUgY29udGVudHMgYXMgdGhlIGJvZHlcbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZmlsZUNvbnRlbnRzLm1hcCwgZmlsZUNvbnRlbnRzLmxvZ2ljLCBmaWxlQ29udGVudHMuY29tYmluYXRpb25zKVxuICB9XG4gIHJlYWRlci5yZWFkQXNUZXh0KG1hcEZpbGUpXG59XG5cbi8vIHJlYWQgc291cmNlIGRhdGEgdXNpbmcgdGhlIHByb3BlciBsb2FkZXJcbmNvbnN0IHJlYWRTb3VyY2VEYXRhID0gKGZvcm1hdCwgZmlsZXMsIG1hcCwgbG9naWMsIGNhbGxiYWNrKSA9PiB7XG4gIHN3aXRjaChmb3JtYXQpe1xuICAgIGNhc2UgJy5jc3YnOlxuICAgICAgcmV0dXJuIGxvYWRDU1YoZmlsZXMsIG1hcCwgbG9naWMsIGNhbGxiYWNrKVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY2FsbGJhY2soJ0VSUk9SJylcbiAgfVxufVxuXG4vLyBjb21iaW5lIGZpZWxkcyB3aGVyZSBuZWNlc3NhcnkuIFRoaXMgb2NjdXJzIG9ubHkgYWZ0ZXIgdGhlIHVzZXIgY2xpY2tzIHRoZSB1cGxvYWQgYnV0dG9uXG4vLyB0byB1cGxvYWQgdGhlaXIgc2FtcGxlcyB0byBTRVNBUlxuY29uc3QgY29tYmluZUZpZWxkcyA9IChjb21iaW5hdGlvbnMsIG1hcCwgdXBsb2FkU2FtcGxlcykgPT4ge1xuICBmb3IobGV0IGk9MDsgaTx1cGxvYWRTYW1wbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yKGxldCBrZXkgaW4gbWFwKSB7XG4gICAgICBpZihBcnJheS5pc0FycmF5KG1hcFtrZXldKSkge1xuICAgICAgICBsZXQgZmlsdGVyID0gdXBsb2FkU2FtcGxlc1tpXS5maWx0ZXIoKHZhbHVlKSA9PiBtYXBba2V5XS5pbmNsdWRlcyh2YWx1ZS5vcmlnaW5hbEtleSkpXG4gICAgICAgIGxldCBpbnZlcnNlID0gdXBsb2FkU2FtcGxlc1tpXS5maWx0ZXIoKHZhbHVlKSA9PiAhbWFwW2tleV0uaW5jbHVkZXModmFsdWUub3JpZ2luYWxLZXkpKVxuICAgICAgICBpZihmaWx0ZXIubGVuZ3RoPjEpIHtcbiAgICAgICAgICBsZXQgcmVkdWN0aW9uID0gZmlsdGVyLnJlZHVjZSgoYWNjLCBmaWVsZCkgPT4gYWNjLmNvbmNhdChbZmllbGQudmFsdWVdKSwgW10pXG4gICAgICAgICAgaWYoY29tYmluYXRpb25zW2tleV0pIHtcbiAgICAgICAgICAgIGxldCBuZXdGaWVsZCA9IHtrZXksIHZhbHVlOiBjb21iaW5hdGlvbnNba2V5XShyZWR1Y3Rpb24pfVxuICAgICAgICAgICAgaW52ZXJzZS5wdXNoKG5ld0ZpZWxkKVxuICAgICAgICAgICAgdXBsb2FkU2FtcGxlc1tpXSA9IGludmVyc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihmaWx0ZXIubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICBpbnZlcnNlLmNvbmNhdChmaWx0ZXIpXG4gICAgICAgICAgdXBsb2FkU2FtcGxlc1tpXSA9IGludmVyc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdXBsb2FkU2FtcGxlc1xufVxuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vLyBsb2FkZXJzIGhhbmRsZSB0aGUgbG9naWMgZm9yIHdoYXRldmVyIGZpbGUgZm9ybWF0IGlzIGdpdmVuXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbi8vIGNyZWF0ZUZpZWxkIGlzIGEgaGVscGVyIGZ1bmN0aW9uIGZvciBhbGwgdGhlIGxvYWRlcnMgdGhhdCBidWlsZHMgZWFjaCBmaWVsZFxuLy8gZm9yIE1BUlNcbmNvbnN0IGNyZWF0ZUZpZWxkID0gKGtleSwgb3JpZ2luYWxWYWx1ZSwgb3JpZ2luYWxLZXksIGxvZ2ljKSA9PiB7XG4gIGlmKCFrZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb3JpZ2luYWxLZXksXG4gICAgICBvcmlnaW5hbFZhbHVlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvcmlnaW5hbEtleSxcbiAgICBvcmlnaW5hbFZhbHVlLFxuICAgIGtleSxcbiAgICB2YWx1ZTogbG9naWNba2V5XSA/IGxvZ2ljW2tleV0ob3JpZ2luYWxWYWx1ZSwgb3JpZ2luYWxLZXkpIDogb3JpZ2luYWxWYWx1ZVxuICB9XG59XG5cbi8vIExvYWQgQ1NWIGZpbGVzIGJ5IG1lcmdpbmcgdGhlbVxuY29uc3QgbG9hZENTViA9IChmaWxlcywgbWFwLCBsb2dpYywgY2FsbGJhY2spID0+IHtcblxuICBsZXQgc2FtcGxlcyA9IFtdXG4gIGxldCBjb3VudGVyID0gMFxuXG4gIGZvcihsZXQgaT0wOyBpPGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gY2xvc3VyZSByZWFkcyBlYWNoIGZpbGUgYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gY29tcGxldGVkXG4gICAgKChmaWxlKSA9PiB7XG5cbiAgICAgIC8vIGNyZWF0ZSBhIGZpbGVSZWFkZXIgZm9yIGVhY2ggZmlsZVxuICAgICAgbGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKClcblxuICAgICAgLy8gQmVjYXVzZSBGaWxlUmVhZGVyIGlzIGFzeW5jaHJvbm91cywgdGhlcmUgaXMgbm8gZ3VhcmFudGVlZCBvcmRlciBpblxuICAgICAgLy8gd2hpY2ggZWFjaCBmaWxlIHdpbGwgZmlyZSB0aGUgb25sb2FkZW5kIGV2ZW50XG4gICAgICByZWFkZXIub25sb2FkZW5kID0gKGUpID0+IHtcbiAgICAgICAgLy8gY3N2UGFyc2UgaXMgYSBEMyBmdW5jdGlvbiB0aGF0IGxvYWRzIGEgY3N2IHN0cmluZy4gSXQgdGFrZXMgYSBmdW5jdGlvblxuICAgICAgICAvLyB3aGljaCBoYW5kbGVzIHRoZSBsb2dpYyBmb3IgbWFwcGluZyBlYWNoIGluZGl2aWR1YWwgc2FtcGxlXG4gICAgICAgIGNzdlBhcnNlKGUudGFyZ2V0LnJlc3VsdCwgKGQsIGkpID0+IHtcbiAgICAgICAgICBpZighc2FtcGxlc1tpXSkge3NhbXBsZXNbaV0gPSBbXX1cbiAgICAgICAgICBmb3IobGV0IGtleSBpbiBtYXApIHtcbiAgICAgICAgICAgIGlmKEFycmF5LmlzQXJyYXkobWFwW2tleV0pKSB7XG4gICAgICAgICAgICAgIGZvcihsZXQgaj0wOyBqPG1hcFtrZXldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYoZFttYXBba2V5XVtqXV0pIHtcbiAgICAgICAgICAgICAgICAgIHNhbXBsZXNbaV0ucHVzaChjcmVhdGVGaWVsZChrZXksIGRbbWFwW2tleV1bal1dLCBtYXBba2V5XVtqXSwgbG9naWMpKVxuICAgICAgICAgICAgICAgICAgZGVsZXRlIGRbbWFwW2tleV1baV1dXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYoZFttYXBba2V5XV0pe1xuICAgICAgICAgICAgICBzYW1wbGVzW2ldLnB1c2goY3JlYXRlRmllbGQoa2V5LCBkW21hcFtrZXldXSwgbWFwW2tleV0sIGxvZ2ljKSlcbiAgICAgICAgICAgICAgZGVsZXRlIGRbbWFwW2tleV1dXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEdldCB0aGUgdW5tYXBwZWQgc2FtcGxlc1xuICAgICAgICAgIGZvcihsZXQga2V5IGluIGQpIHtcbiAgICAgICAgICAgIGRba2V5XSA/IHNhbXBsZXNbaV0ucHVzaChjcmVhdGVGaWVsZCh1bmRlZmluZWQsIGRba2V5XSwga2V5LCBsb2dpYykpIDogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gdGhlIGNvdW50ZXIgaGVscHMgdXMga25vdyB3aGVuIGFsbCB0aGUgZmlsZXMgaGF2ZSBiZWVuIGxvYWRlZCBieSBjb3VudGluZ1xuICAgICAgICAvLyB0aGUgbnVtYmVyIG9mIGxvYWRlbmQgZXZlbnRzIHRoYXQgYXJlIGZpcmVkXG4gICAgICAgIGNvdW50ZXIrK1xuICAgICAgICBpZihjb3VudGVyID09IGZpbGVzLmxlbmd0aCkge1xuXG4gICAgICAgICAgLy8gZmlsdGVyIHJlcGVhdHMgd2l0aCBoYXNoIHRhYmxlc1xuICAgICAgICAgIGZvcihsZXQgaT0wOyBpPHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzZWVuID0ge31cbiAgICAgICAgICAgIHNhbXBsZXNbaV0gPSBzYW1wbGVzW2ldLmZpbHRlcihmaWVsZCA9PiBzZWVuLmhhc093blByb3BlcnR5KGZpZWxkLm9yaWdpbmFsS2V5KSA/IGZhbHNlIDogKHNlZW5bZmllbGQub3JpZ2luYWxLZXldKSA9IHRydWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHNhbXBsZXMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpXG4gICAgfSkoZmlsZXNbaV0pIC8vIGVuZCBjbG9zdXJlXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tYXJzL2NvbXBvbmVudHMvQXBwL2NvbXBvbmVudHMvVXBsb2FkL2hlbHBlcnMvc2FuZGJveC5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	eval("// https://d3js.org/d3-dsv/ Version 1.0.7. Copyright 2017 Mike Bostock.\n(function (global, factory) {\n\t true ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.d3 = global.d3 || {})));\n}(this, (function (exports) { 'use strict';\n\nvar EOL = {};\nvar EOF = {};\nvar QUOTE = 34;\nvar NEWLINE = 10;\nvar RETURN = 13;\n\nfunction objectConverter(columns) {\n  return new Function(\"d\", \"return {\" + columns.map(function(name, i) {\n    return JSON.stringify(name) + \": d[\" + i + \"]\";\n  }).join(\",\") + \"}\");\n}\n\nfunction customConverter(columns, f) {\n  var object = objectConverter(columns);\n  return function(row, i) {\n    return f(object(row), i, columns);\n  };\n}\n\n// Compute unique columns in order of discovery.\nfunction inferColumns(rows) {\n  var columnSet = Object.create(null),\n      columns = [];\n\n  rows.forEach(function(row) {\n    for (var column in row) {\n      if (!(column in columnSet)) {\n        columns.push(columnSet[column] = column);\n      }\n    }\n  });\n\n  return columns;\n}\n\nvar dsv = function(delimiter) {\n  var reFormat = new RegExp(\"[\\\"\" + delimiter + \"\\n\\r]\"),\n      DELIMITER = delimiter.charCodeAt(0);\n\n  function parse(text, f) {\n    var convert, columns, rows = parseRows(text, function(row, i) {\n      if (convert) return convert(row, i - 1);\n      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);\n    });\n    rows.columns = columns;\n    return rows;\n  }\n\n  function parseRows(text, f) {\n    var rows = [], // output rows\n        N = text.length,\n        I = 0, // current character index\n        n = 0, // current line number\n        t, // current token\n        eof = N <= 0, // current token followed by EOF?\n        eol = false; // current token followed by EOL?\n\n    // Strip the trailing newline.\n    if (text.charCodeAt(N - 1) === NEWLINE) --N;\n    if (text.charCodeAt(N - 1) === RETURN) --N;\n\n    function token() {\n      if (eof) return EOF;\n      if (eol) return eol = false, EOL;\n\n      // Unescape quotes.\n      var i, j = I, c;\n      if (text.charCodeAt(j) === QUOTE) {\n        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);\n        if ((i = I) >= N) eof = true;\n        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        return text.slice(j + 1, i - 1).replace(/\"\"/g, \"\\\"\");\n      }\n\n      // Find next delimiter or newline.\n      while (I < N) {\n        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;\n        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }\n        else if (c !== DELIMITER) continue;\n        return text.slice(j, i);\n      }\n\n      // Return last token before EOF.\n      return eof = true, text.slice(j, N);\n    }\n\n    while ((t = token()) !== EOF) {\n      var row = [];\n      while (t !== EOL && t !== EOF) row.push(t), t = token();\n      if (f && (row = f(row, n++)) == null) continue;\n      rows.push(row);\n    }\n\n    return rows;\n  }\n\n  function format(rows, columns) {\n    if (columns == null) columns = inferColumns(rows);\n    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {\n      return columns.map(function(column) {\n        return formatValue(row[column]);\n      }).join(delimiter);\n    })).join(\"\\n\");\n  }\n\n  function formatRows(rows) {\n    return rows.map(formatRow).join(\"\\n\");\n  }\n\n  function formatRow(row) {\n    return row.map(formatValue).join(delimiter);\n  }\n\n  function formatValue(text) {\n    return text == null ? \"\"\n        : reFormat.test(text += \"\") ? \"\\\"\" + text.replace(/\"/g, \"\\\"\\\"\") + \"\\\"\"\n        : text;\n  }\n\n  return {\n    parse: parse,\n    parseRows: parseRows,\n    format: format,\n    formatRows: formatRows\n  };\n};\n\nvar csv = dsv(\",\");\n\nvar csvParse = csv.parse;\nvar csvParseRows = csv.parseRows;\nvar csvFormat = csv.format;\nvar csvFormatRows = csv.formatRows;\n\nvar tsv = dsv(\"\\t\");\n\nvar tsvParse = tsv.parse;\nvar tsvParseRows = tsv.parseRows;\nvar tsvFormat = tsv.format;\nvar tsvFormatRows = tsv.formatRows;\n\nexports.dsvFormat = dsv;\nexports.csvParse = csvParse;\nexports.csvParseRows = csvParseRows;\nexports.csvFormat = csvFormat;\nexports.csvFormatRows = csvFormatRows;\nexports.tsvParse = tsvParse;\nexports.tsvParseRows = tsvParseRows;\nexports.tsvFormat = tsvFormat;\nexports.tsvFormatRows = tsvFormatRows;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2QzLWRzdi9idWlsZC9kMy1kc3YuanM/OTFhMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxDQUFDLDRCQUE0Qjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLEdBQUcsZ0JBQWdCO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWSx5Q0FBeUM7QUFDckY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWSx5Q0FBeUM7QUFDckY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxjQUFjOztBQUU1RCxDQUFDIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2QzanMub3JnL2QzLWRzdi8gVmVyc2lvbiAxLjAuNy4gQ29weXJpZ2h0IDIwMTcgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgRU9MID0ge307XG52YXIgRU9GID0ge307XG52YXIgUVVPVEUgPSAzNDtcbnZhciBORVdMSU5FID0gMTA7XG52YXIgUkVUVVJOID0gMTM7XG5cbmZ1bmN0aW9uIG9iamVjdENvbnZlcnRlcihjb2x1bW5zKSB7XG4gIHJldHVybiBuZXcgRnVuY3Rpb24oXCJkXCIsIFwicmV0dXJuIHtcIiArIGNvbHVtbnMubWFwKGZ1bmN0aW9uKG5hbWUsIGkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobmFtZSkgKyBcIjogZFtcIiArIGkgKyBcIl1cIjtcbiAgfSkuam9pbihcIixcIikgKyBcIn1cIik7XG59XG5cbmZ1bmN0aW9uIGN1c3RvbUNvbnZlcnRlcihjb2x1bW5zLCBmKSB7XG4gIHZhciBvYmplY3QgPSBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucyk7XG4gIHJldHVybiBmdW5jdGlvbihyb3csIGkpIHtcbiAgICByZXR1cm4gZihvYmplY3Qocm93KSwgaSwgY29sdW1ucyk7XG4gIH07XG59XG5cbi8vIENvbXB1dGUgdW5pcXVlIGNvbHVtbnMgaW4gb3JkZXIgb2YgZGlzY292ZXJ5LlxuZnVuY3Rpb24gaW5mZXJDb2x1bW5zKHJvd3MpIHtcbiAgdmFyIGNvbHVtblNldCA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBjb2x1bW5zID0gW107XG5cbiAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgIGZvciAodmFyIGNvbHVtbiBpbiByb3cpIHtcbiAgICAgIGlmICghKGNvbHVtbiBpbiBjb2x1bW5TZXQpKSB7XG4gICAgICAgIGNvbHVtbnMucHVzaChjb2x1bW5TZXRbY29sdW1uXSA9IGNvbHVtbik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29sdW1ucztcbn1cblxudmFyIGRzdiA9IGZ1bmN0aW9uKGRlbGltaXRlcikge1xuICB2YXIgcmVGb3JtYXQgPSBuZXcgUmVnRXhwKFwiW1xcXCJcIiArIGRlbGltaXRlciArIFwiXFxuXFxyXVwiKSxcbiAgICAgIERFTElNSVRFUiA9IGRlbGltaXRlci5jaGFyQ29kZUF0KDApO1xuXG4gIGZ1bmN0aW9uIHBhcnNlKHRleHQsIGYpIHtcbiAgICB2YXIgY29udmVydCwgY29sdW1ucywgcm93cyA9IHBhcnNlUm93cyh0ZXh0LCBmdW5jdGlvbihyb3csIGkpIHtcbiAgICAgIGlmIChjb252ZXJ0KSByZXR1cm4gY29udmVydChyb3csIGkgLSAxKTtcbiAgICAgIGNvbHVtbnMgPSByb3csIGNvbnZlcnQgPSBmID8gY3VzdG9tQ29udmVydGVyKHJvdywgZikgOiBvYmplY3RDb252ZXJ0ZXIocm93KTtcbiAgICB9KTtcbiAgICByb3dzLmNvbHVtbnMgPSBjb2x1bW5zO1xuICAgIHJldHVybiByb3dzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VSb3dzKHRleHQsIGYpIHtcbiAgICB2YXIgcm93cyA9IFtdLCAvLyBvdXRwdXQgcm93c1xuICAgICAgICBOID0gdGV4dC5sZW5ndGgsXG4gICAgICAgIEkgPSAwLCAvLyBjdXJyZW50IGNoYXJhY3RlciBpbmRleFxuICAgICAgICBuID0gMCwgLy8gY3VycmVudCBsaW5lIG51bWJlclxuICAgICAgICB0LCAvLyBjdXJyZW50IHRva2VuXG4gICAgICAgIGVvZiA9IE4gPD0gMCwgLy8gY3VycmVudCB0b2tlbiBmb2xsb3dlZCBieSBFT0Y/XG4gICAgICAgIGVvbCA9IGZhbHNlOyAvLyBjdXJyZW50IHRva2VuIGZvbGxvd2VkIGJ5IEVPTD9cblxuICAgIC8vIFN0cmlwIHRoZSB0cmFpbGluZyBuZXdsaW5lLlxuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoTiAtIDEpID09PSBORVdMSU5FKSAtLU47XG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChOIC0gMSkgPT09IFJFVFVSTikgLS1OO1xuXG4gICAgZnVuY3Rpb24gdG9rZW4oKSB7XG4gICAgICBpZiAoZW9mKSByZXR1cm4gRU9GO1xuICAgICAgaWYgKGVvbCkgcmV0dXJuIGVvbCA9IGZhbHNlLCBFT0w7XG5cbiAgICAgIC8vIFVuZXNjYXBlIHF1b3Rlcy5cbiAgICAgIHZhciBpLCBqID0gSSwgYztcbiAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaikgPT09IFFVT1RFKSB7XG4gICAgICAgIHdoaWxlIChJKysgPCBOICYmIHRleHQuY2hhckNvZGVBdChJKSAhPT0gUVVPVEUgfHwgdGV4dC5jaGFyQ29kZUF0KCsrSSkgPT09IFFVT1RFKTtcbiAgICAgICAgaWYgKChpID0gSSkgPj0gTikgZW9mID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoKGMgPSB0ZXh0LmNoYXJDb2RlQXQoSSsrKSkgPT09IE5FV0xJTkUpIGVvbCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFJFVFVSTikgeyBlb2wgPSB0cnVlOyBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSBORVdMSU5FKSArK0k7IH1cbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiArIDEsIGkgLSAxKS5yZXBsYWNlKC9cIlwiL2csIFwiXFxcIlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCBuZXh0IGRlbGltaXRlciBvciBuZXdsaW5lLlxuICAgICAgd2hpbGUgKEkgPCBOKSB7XG4gICAgICAgIGlmICgoYyA9IHRleHQuY2hhckNvZGVBdChpID0gSSsrKSkgPT09IE5FV0xJTkUpIGVvbCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFJFVFVSTikgeyBlb2wgPSB0cnVlOyBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSBORVdMSU5FKSArK0k7IH1cbiAgICAgICAgZWxzZSBpZiAoYyAhPT0gREVMSU1JVEVSKSBjb250aW51ZTtcbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiwgaSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBsYXN0IHRva2VuIGJlZm9yZSBFT0YuXG4gICAgICByZXR1cm4gZW9mID0gdHJ1ZSwgdGV4dC5zbGljZShqLCBOKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoKHQgPSB0b2tlbigpKSAhPT0gRU9GKSB7XG4gICAgICB2YXIgcm93ID0gW107XG4gICAgICB3aGlsZSAodCAhPT0gRU9MICYmIHQgIT09IEVPRikgcm93LnB1c2godCksIHQgPSB0b2tlbigpO1xuICAgICAgaWYgKGYgJiYgKHJvdyA9IGYocm93LCBuKyspKSA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgIH1cblxuICAgIHJldHVybiByb3dzO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KHJvd3MsIGNvbHVtbnMpIHtcbiAgICBpZiAoY29sdW1ucyA9PSBudWxsKSBjb2x1bW5zID0gaW5mZXJDb2x1bW5zKHJvd3MpO1xuICAgIHJldHVybiBbY29sdW1ucy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKV0uY29uY2F0KHJvd3MubWFwKGZ1bmN0aW9uKHJvdykge1xuICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUocm93W2NvbHVtbl0pO1xuICAgICAgfSkuam9pbihkZWxpbWl0ZXIpO1xuICAgIH0pKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Um93cyhyb3dzKSB7XG4gICAgcmV0dXJuIHJvd3MubWFwKGZvcm1hdFJvdykuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFJvdyhyb3cpIHtcbiAgICByZXR1cm4gcm93Lm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodGV4dCkge1xuICAgIHJldHVybiB0ZXh0ID09IG51bGwgPyBcIlwiXG4gICAgICAgIDogcmVGb3JtYXQudGVzdCh0ZXh0ICs9IFwiXCIpID8gXCJcXFwiXCIgKyB0ZXh0LnJlcGxhY2UoL1wiL2csIFwiXFxcIlxcXCJcIikgKyBcIlxcXCJcIlxuICAgICAgICA6IHRleHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhcnNlOiBwYXJzZSxcbiAgICBwYXJzZVJvd3M6IHBhcnNlUm93cyxcbiAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICBmb3JtYXRSb3dzOiBmb3JtYXRSb3dzXG4gIH07XG59O1xuXG52YXIgY3N2ID0gZHN2KFwiLFwiKTtcblxudmFyIGNzdlBhcnNlID0gY3N2LnBhcnNlO1xudmFyIGNzdlBhcnNlUm93cyA9IGNzdi5wYXJzZVJvd3M7XG52YXIgY3N2Rm9ybWF0ID0gY3N2LmZvcm1hdDtcbnZhciBjc3ZGb3JtYXRSb3dzID0gY3N2LmZvcm1hdFJvd3M7XG5cbnZhciB0c3YgPSBkc3YoXCJcXHRcIik7XG5cbnZhciB0c3ZQYXJzZSA9IHRzdi5wYXJzZTtcbnZhciB0c3ZQYXJzZVJvd3MgPSB0c3YucGFyc2VSb3dzO1xudmFyIHRzdkZvcm1hdCA9IHRzdi5mb3JtYXQ7XG52YXIgdHN2Rm9ybWF0Um93cyA9IHRzdi5mb3JtYXRSb3dzO1xuXG5leHBvcnRzLmRzdkZvcm1hdCA9IGRzdjtcbmV4cG9ydHMuY3N2UGFyc2UgPSBjc3ZQYXJzZTtcbmV4cG9ydHMuY3N2UGFyc2VSb3dzID0gY3N2UGFyc2VSb3dzO1xuZXhwb3J0cy5jc3ZGb3JtYXQgPSBjc3ZGb3JtYXQ7XG5leHBvcnRzLmNzdkZvcm1hdFJvd3MgPSBjc3ZGb3JtYXRSb3dzO1xuZXhwb3J0cy50c3ZQYXJzZSA9IHRzdlBhcnNlO1xuZXhwb3J0cy50c3ZQYXJzZVJvd3MgPSB0c3ZQYXJzZVJvd3M7XG5leHBvcnRzLnRzdkZvcm1hdCA9IHRzdkZvcm1hdDtcbmV4cG9ydHMudHN2Rm9ybWF0Um93cyA9IHRzdkZvcm1hdFJvd3M7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vZDMtZHN2L2J1aWxkL2QzLWRzdi5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ })
/******/ ]);